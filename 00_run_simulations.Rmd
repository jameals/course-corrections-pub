---
title: "00_run_simulations"
author: "Jameal Samhouri & Raine Detmer"
date: '`r Sys.Date()`'
output: html_document
---

README: code for defining parameters and running all the simulations used to make the main text and supplemental figures (outputs from these simulations are stored as .csv files in the "simulation output" folder)

load packages

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

library("tidyverse")

options(dplyr.summarise.inform = FALSE)# get rid of the "summarize has grouped output by..." warnings

```



# define parameters

Define the default parameters 


```{r}
years<-100 # max number of years in simulation 

K_A <- 1000 # high carrying capacity
K_B <- 0.25*K_A # low carrying capacity
r_A <- 0.25 # high population growth rate
r_B <- 0.25*r_A # low population growth rate

B_cons <- 0.25 # conservation limit (min biomass--expressed as fraction of carrying capacity-- below which population is of conservation concern)

chng_pt <- 1 # time point at which parameter (K or r or both) begins to change in the gradual scenarios
chng_pt2 <- 50 # time point at which parameter (K or r or both) changes to final value 

chng_time2 <- chng_pt2

update_int <- 4 # number of years between parameter updates in the gradual climate adaptive scenario with periodic readjustments

change_refs <- c(0, 1, 2) # 0 = status quo, 1 = abrupt climate adaptive, 2 = gradual climate adaptive
strat_names <- c("SQ", "ACA", "GCA") # names of each of the management strategies specified by change_ref

p <- 1 # price per unit biomass
delta_set <- c(0.01) # set of discount rates to simulate the model with; don't need to include 0 because revenue with delta = 0 is just equal harvest (if price is 1)


# fixed HCR parameters (don't depend on current biomass)
alpha_HCR <- 0.2 # slope of sloped HCR 
HCR_fixed_pars <- list(alpha_HCR = alpha_HCR)

Uinit <- 0 # initial harvest rate


# function for sliding/sloped HCR

# function of current biomass B, carrying capacity K (either true or effective depending on strategy) and max harvest rate U_max (e.g., U_MSY, which could either be based on true or effective r based on strategy), and the alpha parameter alpha_HCR controlling the steepness of the HCR
# all of these arguments are combined in a list called HCR_pars, which is created within the function for simulating the model
slope_HCR <- function(HCR_pars){

  B <- HCR_pars$B
  K <- HCR_pars$K
  U_max <- HCR_pars$U_max
  alpha_HCR <- HCR_pars$alpha_HCR

  BMSY<-K/2

  # calculate actual harvest rate as a function of target rate (U_max) and B/B_MSY
  if(B/BMSY < alpha_HCR){
    U_t <- 0
  }
  if(B/BMSY >= alpha_HCR & B/BMSY<1){
    U_t <- (U_max*(B/BMSY - alpha_HCR))/(1-alpha_HCR)
  }

  if(B/BMSY >=1){
    U_t <- U_max
  }


  C_t <- U_t*B

  return(C_t) # return harvest rate at time t x biomass at time t

}


HCR_fun <- slope_HCR # default HCR to use (see HCR_funs.R in the functions folder for all of the HCR functions)

# no stochasticity
no_errors <- rep(1, years)

# r and K timeseries for all the different scenarios

# functions for making these timeseries
# piece-wise function for specifying gradual change in a parameter (K or r)
# chng_pt = time point at which the parameter starts changing
# chng_time2 = time point at which the parameter stops changing and reaches its new value
# years = total number of years for which to return values of the parameter
# par = vector of parameter values where the first element is the initial value and the last element is the end value
par_for_fun <- function(chng_pt, chng_time2, years, par){

  par_for <- rep(NA, years)

  for(i in 1:years){

    if(i <= chng_pt){ # if the year is less than the chng_pt
      par_for[i] <- par[1] # par_for is equal to par[1] (haven't started gradual change yet)

    } else if(i > chng_pt & i <= chng_time2){
      # after the chng_pt, use equation of a line to capture gradual change in par_for
      # y = (y2-y1)/(x2-x1)*x + b -> here y2 = par[length(par)] (the end value), y1 = par[1] (the initial value), b is par[1], and the difference x2-x1 is the amount of time it takes for par_for to change from the high to low value
      # and also need to shift to this line to the right by the amount chng_pt so the decline starts at chng_pt rather than 0 (or set chng_pt = 0)
      par_for[i] <- par[1] + (par[length(par)] - par[1])/(chng_time2-chng_pt)*(i-chng_pt)

    } else {
      par_for[i] <- par[length(par)] # after t = chng_time2, par_for is equal to par_B
    }

  }

  return(par_for)

}


# piece-wise function for specifying periodic changes in a parameter (K or r)
# chng_pt = time point at which the parameter starts changing
# chng_time2 = time point at which the parameter stops changing and reaches its new value
# years = total number of years for which to return values of the parameter
# par = vector of parameter values where the first element is the initial value and the last element is the end value
# update_int = frequency at which the estimate of the parameter is updated

update_par_fun <- function(chng_pt, chng_time2, years, par, update_int){

  # first get the continuously changing parmaeter values
  par_for <- rep(NA, years)

  for(i in 1:years){

    if(i <= chng_pt){ # if the year is less than the chng_pt
      par_for[i] <- par[1] # par_for is equal to par[1] (haven't started gradual change yet)

    } else if(i > chng_pt & i <= chng_time2){
      # after the chng_pt, use equation of a line to capture gradual change in par_for
      # y = (y2-y1)/(x2-x1)*x + b -> here y2 = par[length(par)] (the end value), y1 = par[1] (the initial value), b is par[1], and the difference x2-x1 is the amount of time it takes for par_for to change from the high to low value
      # and also need to shift to this line to the right by the amount chng_pt so the decline starts at chng_pt rather than 0 (or set chng_pt = 0)
      par_for[i] <- par[1] + (par[length(par)] - par[1])/(chng_time2-chng_pt)*(i-chng_pt)

    } else {
      par_for[i] <- par[length(par)] # after t = chng_time2, par_for is equal to par_B
    }

  }

  # now get the parmeter values that are updated to match the continuously changing values evey update_int years

  update_par <- rep(NA, years)
  update_par[1] <- par_for[1]

  update_pts <- seq(from = 1, to = years, by = update_int)

  for(i in 2:years){

    if(i %in% update_pts){

      update_par[i] <- par_for[i]

    } else{
      update_par[i] <- update_par[i-1]
    }


  }

  return(update_par)

}

r_fixedd <- rep(r_A, years) # fixed growth rate, higher value at all timepoints
# step decrease
r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years)))
# gradual decrease
r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)
# step increase
r_stepi <- rev(r_stepd)
# gradual increase
r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

# alternative gradual change w/ periodic course corrections
r_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepd, update_int)
r_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepi, update_int)


K_fixedd <- rep(K_A, years) # fixed carrying capacity, higher value at all timepoints
# step decrease
K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years)))
# gradual decrease
K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)
# step increase
K_stepi <- rev(K_stepd)
# gradual increase
K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

# alternative gradual change w/ periodic course corrections
K_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepd, update_int)
K_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepi, update_int)


```


```{r}
# check the r and K parameter sets

# decreases
plot(x = c(1:years), y = K_fixedd, type = "l", ylim = c(0, 1000), xlab = "year", ylab = "carrying capacity")
lines(x = c(1:years), y = K_stepd, lty = 2)
lines(x = c(1:years), y = K_gradd, lty = 3)
lines(x = c(1:years), y = K_gradd_up, lty = 4)

plot(x = c(1:years), y = r_fixedd, type = "l", ylim = c(0, 0.25), xlab = "year", ylab = "growth rate")
lines(x = c(1:years), y = r_stepd, lty = 2)
lines(x = c(1:years), y = r_gradd, lty = 3)
lines(x = c(1:years), y = r_gradd_up, lty = 4)

# increases
plot(x = c(1:years), y = K_stepi, type = "l", ylim = c(0, 1000), xlab = "year", ylab = "carrying capacity")
lines(x = c(1:years), y = K_gradi, lty = 3)
lines(x = c(1:years), y = K_gradi_up, lty = 4)

plot(x = c(1:years), y = r_stepi, type = "l", ylim = c(0, 0.25), xlab = "year", ylab = "growth rate")
lines(x = c(1:years), y = r_gradi, lty = 3)
lines(x = c(1:years), y = r_gradi_up, lty = 4)

```



# model functions

functions for running the model and summarizing the output

```{r}
# function for simulating the model

# years = number of years to run model
# error_set = vector of multiplicative errors each year (output of var_fun)
# r = true intrinsic population growth rate at each time step
# r_for2 = population growth rate used in HCRs for abrupt climate adaptive strategy
# r_for3 = population growth rate used in HCRs for gradual climate adaptive strategy
# Binit = initial population biomass
# Uinit = initial population harvest rate (note this was Finit in earlier versions)
# K = true population carrying capacity at each time step
# K_for2 = carrying capacity used in HCRs for abrupt climate adaptive strategy
# K_for3 = carrying capacity used in HCRs for gradual climate adaptive strategy
# change_ref = which harvest strategy to use (0 = status quo, 1 = abrupt climate adaptive, 2 = gradual climate adaptive)
# delta_set = vector of discount rates for which to calculate revenue
# p = price per unit biomass
# HCR_fun = function specifying the HCR rule to use
# HCR_fixed_pars = named list with all the fixed (not time varying) parameters for the different possible HCR functions
# use_HCR = whether or not to harvest the population (defaults to TRUE)
# fix_neg = whether or not to force negative biomass to be 0 in stochastic simulations (defaults to TRUE)

proj_pop<-function(years, error_set, r, r_for2, r_for3, Binit, Uinit, K, K_for2, K_for3, change_ref,
                   delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE, fix_neg = TRUE) {

  # holding vectors
  biomass<-rep(NA,years)
  yield<-rep(NA,years)
  harvest_rate<-rep(NA,years)
  #revenue <- rep(NA, years) # revenue

  B_neg <-rep(NA,years) # holding vector to check how often biomass goes negative (if fix_neg = T)

  # set first elements
  biomass[1]<-Binit
  yield[1] <- Binit * Uinit # changed Finit to Uinit to match the equations we've been writing out
  harvest_rate[1] <- Uinit
  #revenue[1] <- yield[1]*p*exp(-delta*1)l

  # simulate the model with HCR
  for(i in 2:years){

    # the full equation for biomass is:
    # B[i] = biomass[i-1]+(r[i-1]*biomass[i-1]*(1-biomass[i-1]/K[i-1]))*exp(epsilon[i-1]-sigma2/2) - U*biomass[i-1]

    # first calculate change in biomass from growth

    # use error structure following Shelton et al. 2014 herring model
    #epsilon[i] <- rnorm(1, rho*epsilon[i-1], sigma2) # epsilon is defined as a rondom variable drawn from a normal distribution in log space

    B_t <- biomass[i-1]+(r[i-1]*biomass[i-1]*(1-biomass[i-1]/K[i-1]))*error_set[i-1]
    # error_set[i-1] = exp(rho*epsilon[i-1]-sigma2/2), from error_fun (epilson is in log space, so exponentiate it to apply it to biomass in real space)
    # B_t is just the biomass before adding the harvest term (which depends on the HCR/management strategy and is calculated below) so it does not need to be tracked over time

    # now calculate the harvest term (yield)
    if(use_HCR==FALSE){

      biomass[i] <- B_t
      yield[i] <- 0
      harvest_rate[i] <- 0

      # check whether biomass went negative
      if(biomass[i] < 0){

        if(fix_neg == T){ # if you want to fix it
          # record the negative biomass value
          B_neg[i] <- biomass[i]

          biomass[i] <- 0 # force biomass to be zero
        }

      }


    } else{ # if the population is harvested

      # get the harvest component
      if(change_ref ==0){ # status quo scenario

        # B, K, U_max, B_target
        HCR_pars <- c(HCR_fixed_pars, list(B = biomass[i-1], K = K[1], U_max = r[1]/2, B_target = K[1]/2))

        yield[i] <- HCR_fun(HCR_pars) # catch (U*B) at time t

      }


      if(change_ref==1){ # abrupt climate adaptive scenario

        HCR_pars <- c(HCR_fixed_pars, list(B = biomass[i-1], K = K_for2[i-1], U_max = r_for2[i-1]/2, B_target = K_for2[i-1]/2))
        #HCR_pars <- c(HCR_fixed_pars, list(B = biomass[i-1], K = K_for2[i], U_max = r_for2[i-1]/2, B_target = K_for2[i]/2))

        yield[i] <- HCR_fun(HCR_pars) # catch at time t

      }

      if(change_ref==2){ # gradual climate adaptive scenario

        HCR_pars <- c(HCR_fixed_pars, list(B = biomass[i-1], K = K_for3[i-1], U_max = r_for3[i-1]/2, B_target = K_for3[i-1]/2))
        #HCR_pars <- c(HCR_fixed_pars, list(B = biomass[i-1], K = K_for3[i], U_max = r_for3[i]/2, B_target = K_for3[i]/2))

        yield[i] <- HCR_fun(HCR_pars) # catch at time t

      }

      biomass[i] <- B_t - yield[i] # biomass remaining after harvest

      # check whether biomass went negative
      if(biomass[i] < 0){

        if(fix_neg == T){ # if you want to fix it
          # record the negative biomass value
          B_neg[i] <- biomass[i]
          biomass[i] <- 0 # force biomass to be zero
          #yield[i] <- B_t # only take as many fish as were left
        }

      }

      # calculate harvest rate
      harvest_rate[i] <- ifelse(biomass[i-1] != 0, yield[i]/biomass[i-1], NA)

    }

  }

  # calculate revenue for the discount values in delta_set (since there is currently no effect of delta on
  # the biomass dynamics, we can evaluate the effect of delta without running multiple simulations-- this is just to save computing time)
  revenue_mat <- matrix(NA, nrow = years, ncol = length(delta_set))

  for(j in 1:length(delta_set)){

    revenue_mat[ ,j] <-  yield*p*exp(-delta_set[j]*c(1:years)) #revenue = price x yield x discount factor

  }

  # get the forecast carrying capacities and productivities to return
  if(change_ref==0){ # fixed
    K_for_out <- rep(K[1], length(K))
    r_for_out <- rep(r[1], length(r))
  } else if(change_ref ==1){ # abrupt climate adaptive
    K_for_out <- K_for2
    r_for_out <- r_for2
  } else{ # gradual climate adaptive or periodic updates
    K_for_out <- K_for3
    r_for_out <- r_for3
  }

  # return biomass, yield, harvest_rate, and revenues
  results <- list(biomass=biomass, yield=yield, harvest_rate=harvest_rate, revenue_mat = revenue_mat, B_neg = B_neg,
                  K_true = K, K_fixed = rep(K[1], length(K)), r_true = r,
                  r_fixed = rep(r[1], length(r)), K_for = K_for_out, r_for = r_for_out)

  return(results)

}



# function for generating random components of simulations (if including stochasticity)
# parameters:
# cv = coefficient of variation (=sd/mean) of the variability in population growth, in normal space
# rho = strength of autocorrelation in process error
# years = number of years to get error terms
# nreps = number of replicate simulations to do
# seed = seed for random draws
error_fun <- function(cv, rho, years, nreps, seed){

  # from shelton_etal_2014/Herring Scenarios FIN.R: function for turning CV on the log-normal scale into
  # standard deviations of the normal distribution on log scale
  #log.norm.cv		<- function(cv){
  #sigma2	<-	 log(cv^2 + 1)
  #return(sqrt(sigma2))
  #}

  sigma2	<-	log(cv^2 + 1)
  sigma <- sqrt(sigma2)

  # set the seed
  set.seed(seed)

  # holding list for the error time series for each replicate
  error_list <- list()

  for(j in 1:nreps){ # for each replicate simulation

    epsilon <- rep(NA, years) # holding vector for errors drawn from normal distribution in log space
    error_mult <- rep(NA, years) # holding vector for the multiplicative process uncertainty term in the population dynamics equation

    epsilon[1] <- rnorm(1, -sigma2/2, sigma) # error in log space. if we wanted to choose different values of sigma and rho, we should change this to read: rnorm(1, rho*epsilon[i-1]-sigma2/2, sigma*(1-rho^2)), or something close to that. see https://stats.stackexchange.com/questions/99873/calculating-the-expected-value-and-variance-of-a-log-ar1-process

    error_mult[1] <- exp(epsilon[1])


    for(i in 2:years){

      # error structure following Shelton et al. 2014 herring model
      epsilon[i] <- rnorm(1, rho*epsilon[i-1]-sigma2/2, sigma) # epsilon is defined as a random variable drawn from a normal distribution in log space. if we wanted to choose different values of sigma and rho, we should change this to read: rnorm(1, rho*epsilon[i-1]-sigma2/2, sigma*(1-rho^2)), or something close to that. see https://stats.stackexchange.com/questions/99873/calculating-the-expected-value-and-variance-of-a-log-ar1-process

      # epsilon is in log space, so exponentiate it to get the error term that is multiplied to biomass growth in real space
      error_mult[i] <- exp(epsilon[i])

    }

    error_list[[j]] <- error_mult

  }

  return(error_list) # return the list with the time series of multiplicative process error terms for each simulation replicate

}



# function for making the timeseries dataframes from the simulation outputs
# function for turning the full model output (timeseries) into a dataframe
ts_results_fun <- function(results, par_set){
  B <- results$biomass
  H <- results$yield
  Hr <- results$harvest_rate

  years <- length(results$biomass)

  BMSY_true <- results$K_true/2 # true carrying capacity
  BMSY_fixed <- results$K_fixed/2 # fixed carrying capacity
  UMSY_true <- results$r_true/2 # true productivity
  UMSY_fixed <- results$r_fixed/2 # fixed productivity

  BMSY_for <- results$K_for/2 # forecast carrying capacity
  UMSY_for <- results$r_for/2 # forecast productivity

  B_cons_true <- B_cons*BMSY_true # true conservation biomass limit
  B_cons_fixed <- B_cons*BMSY_fixed # fixed conservation biomass limit

  # growth rate:
  growth <- results$r_true*B*(1-B/results$K_true)
  
  df <- data.frame(
    hcr_type = rep(par_set$hcr_type, years),
    strategy = rep(par_set$strategy, years), # sq (fixed), gca, update_6, update_12, aca
    change_par = rep(par_set$change_par, years), # r, K, both
    change_type = rep(par_set$change_type, years), # true change: grad or step
    direction = rep(par_set$direction, years), # increase or decrease
    B_cons = rep(par_set$B_cons, years), # biomass conservation limit (expressed as a fraction of BMSY)
    Binit = rep(par_set$Binit, years), # initial biomass
    chng_time2 = rep(par_set$chng_time2, years), # timepoint when forecast parameter reaches its new value
    error_rho = rep(par_set$error_rho, years), # error autocorrelation
    error_cv = rep(par_set$error_cv, years), # error cv
    error_rep = rep(par_set$error_rep, years), # error replicate
    time = c(1:years), # timestep
    Biomass=B, # biomass
    Harvest = H, # harvest (yield)
    Harvest_rate = Hr, # harvest rate
    B_cons_true = B_cons_true, # true conservation biomass limit
    B_cons_fixed = B_cons_fixed, # fixed conservation biomass limit
    growth = growth, # growth rate
    BMSY_true = BMSY_true, # true carrying capacity
    BMSY_fixed = BMSY_fixed, # fixed carrying capacity
    UMSY_true = UMSY_true, # true productivity
    UMSY_fixed = UMSY_fixed, # fixed productivity
    BMSY_for = BMSY_for, # forecast carrying capacity
    UMSY_for = UMSY_for) # forecast productivity

  return(df)

}


# function for summarizing the model results into a dataframe with mean biomass, cumulative harvest, etc.

results_fun <- function(results, par_set, t_start, t_end){
  #list(biomass=biomass, yield=yield, harvest_rate=harvest_rate, revenue_mat = revenue_mat)
  B <- results$biomass[t_start:t_end]
  H <- results$yield[t_start:t_end]
  Hr <- results$harvest_rate[t_start:t_end]
  Rmat <- as.matrix(results$revenue_mat[t_start:t_end, ])

  K_true <- results$K_true[t_start:t_end] # true carrying capacity
  K_fixed <- results$K_fixed[t_start:t_end] # fixed carrying capacity
  r_true <- results$r_true[t_start:t_end] # true productivity
  r_fixed <- results$r_fixed[t_start:t_end] # fixed productivity

  N_neg <- length(which(is.na(results$B_neg[t_start:t_end])==F)) # check: did biomass go below zero?

  # calculate proportion years below true and fixed Bcons, B_MSY, 0.2*B_MSY, and U_MSY
  propl_Bcons_true <- length(which(B < par_set$B_cons*K_true/2))/length(B)
  propl_Bcons_fixed <- length(which(B < par_set$B_cons*K_fixed/2))/length(B)
  propl_BMSY_true <- length(which(B < K_true/2))/length(B)
  propl_BMSY_fixed <- length(which(B < K_fixed/2))/length(B)
  propl_0.2BMSY_true <- length(which(B < (0.2*K_true)/2))/length(B)
  propl_0.2BMSY_fixed <- length(which(B < (0.2*K_fixed)/2))/length(B)
  propl_UMSY_true <- length(which(Hr < r_true/2))/length(B)
  propl_UMSY_fixed <- length(which(Hr < r_fixed/2))/length(B)

  delta_set <- par_set$discount_rates # vector of delta values for which revenue was calculated

  if(t_start == 1 & t_end == par_set$years){
    period <-  "tot"
  } else if(t_start ==1 & t_end == par_set$chng_pt2 - 1){
    period <-  "pre"
  } else if(t_start == par_set$chng_pt2 & t_end == par_set$years){
    period <- "post"
  } else {
    period <- paste(as.character(t_start), as.character(t_end), sep = ":")
  }

  # calculate mean + cv of biomass, cumulative + cv of harvest (=yield w/o discount), mean harvest rate, cumulative + cv of revenue w/ discount

  # get cumulative revenue and cv in revenue for each value of delta (discount rate) in delta_set
  Rcm <- rep(NA, length(delta_set))
  Rcv <- rep(NA, length(delta_set))

  for(i in 1:length(delta_set)){
    # get Rcm and Rcv
    #revenue_mat[,i]
    Rcm[i] <- sum(Rmat[,i])
    Rcv[i] <- sd(Rmat[,i])/mean(Rmat[,i])
  }

  # columns are the parameters in par_set and then the summary statistics (mean and cv of biomass, total harvest and cv of harvest, mean harvest rate, total revenue and cv of revenue for each discount rate in delta_set, etc.)
  # note only mean revenue and cv of revenue depend on delta, so the rest of the summary metrics are just replicated for each value of delta in delta_set
  df <- data.frame(
    period = rep(period, length(delta_set)), # pre, post, or tot
    hcr_type = rep(par_set$hcr_type, length(delta_set)),
    strategy = rep(par_set$strategy, length(delta_set)), # sq (fixed), gca, update_6, update_12, aca
    change_par = rep(par_set$change_par, length(delta_set)), # r, K, both
    change_type = rep(par_set$change_type, length(delta_set)), # true change: grad or step
    direction = rep(par_set$direction, length(delta_set)), # increase or decrease
    B_cons = rep(par_set$B_cons, length(delta_set)), # biomass conservation limit (expressed as a fraction of BMSY)
    Binit = rep(par_set$Binit, length(delta_set)), # initial biomass
    chng_time2 = rep(par_set$chng_time2, length(delta_set)), # timepoint when forecast parameter reaches its new value
    discount_rate = delta_set, # discount values
    error_rho = rep(par_set$error_rho, length(delta_set)), # error autocorrelation
    error_cv = rep(par_set$error_cv, length(delta_set)), # error cv
    error_rep = rep(par_set$error_rep, length(delta_set)), # error replicate
    Bmn=rep(mean(B), length(delta_set)), # mean biomass
    Bcv = rep(sd(B)/mean(B), length(delta_set)), # cv in biomass
    Hcm = rep(sum(H), length(delta_set)), # cumulative harvest
    Hcv = rep(sd(H)/mean(H), length(delta_set)), # cv in harvest
    Hrmn = rep(mean(Hr, na.rm = T), length(delta_set)), # mean harvest rate
    Rcm = Rcm, # cumulative revenue
    Rcv = Rcv, # cv in revenue
    N_neg = rep(N_neg, length(delta_set)), # number of years biomass went negative (just a check)
    propl_Bcons_true = rep(propl_Bcons_true, length(delta_set)), # prop. yrs B < true conservation limit
    propl_Bcons_fixed = rep(propl_Bcons_fixed, length(delta_set)), # prop. yrs B < fixed conservation limit
    propl_BMSY_true = rep(propl_BMSY_true, length(delta_set)), # prop. yrs B < true B_MSY
    propl_BMSY_fixed = rep(propl_BMSY_fixed, length(delta_set)), # prop. yrs B < fixed B_MSY
    propl_0.2BMSY_true = rep(propl_0.2BMSY_true, length(delta_set)), # prop. yrs B < 0.2*true B_MSY
    propl_0.2BMSY_fixed = rep(propl_0.2BMSY_fixed, length(delta_set)), # prop. yrs B < 0.2*fixed B_MSY
    propl_UMSY_true = rep(propl_UMSY_true, length(delta_set)), # prop. yrs harvest rate < true U_MSY
    propl_UMSY_fixed = rep(propl_UMSY_fixed, length(delta_set))) # prop. yrs harvest rate < fixed U_MSY
    #C_lim = rep(C_lim, length(delta_set)))

  # covert from wide to long
  df_long <- gather(df, metric, value, Bmn:propl_UMSY_fixed)

  return(df_long)

}




```




# run simulations

need to make ABCDsens_df, ABCDsens_update_df, ABts_df, B0sens_df, Tchng_df.csv

## ABts

Full timeseries for all the default r, K, and rK increase/decrease scenarios

```{r}


# function for running simulations for all the different parameter change/management strategy
# scenarios and saving the whole timeseries
tsruns_fun <- function(change_par_x, K_A, K_B, r_A, r_B, update_ints){
  # here K_A is high, K_B is low

  # make the fixed parameter sets
  K_fixed <- rep(K_A, years)
  r_fixed <- rep(r_A, years)

  # step decrease (true parameter has step decrease)
  change_type_x <- "step"
  direction_x <- "decrease"

    # get the parameters to use
    if(change_par_x == "K"){

      K_low <- K_B
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      K <- K_stepd; K_for2 <- K_stepd; K_for3 <- K_gradd
      #Binit <- 0.4*K[1]
      Binit <- K[1]/2

      r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
      Uinit <- r[1]/2

      par_A <- as.character(K_A); par_B <- as.character(K_low)
    }

    if(change_par_x == "r"){
      r_low <- r_B
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
      Binit <- K[1]/2

      r <- r_stepd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- as.character(r_A); par_B <- as.character(r_low)

    }

    if(change_par_x == "rK"){
      K_low <- K_B
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      r_low <- r_B
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_stepd; K_for2 <- K_stepd; K_for3 <- K_gradd
      Binit <- K[1]/2

      r <- r_stepd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

    }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
       all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

  step_dec_s <- dfs_mm


  # step increase (true parameter has step increase)
  change_type_x <- "step"
  direction_x <- "increase"

    # get the parameters to use
    if(change_par_x == "K"){

      K_high <- K_A
      K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
      K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

      K <- K_stepi; K_for2 <- K_stepi; K_for3 <- K_gradi
      Binit <- K[1]/2

      r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
      Uinit <- r[1]/2

      par_A <- as.character(K_B); par_B <- as.character(K_high)
    }

    if(change_par_x == "r"){
      r_high <- r_A
      r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
      r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

      K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
      Binit <- K[1]/2

      r <- r_stepi; r_for2 <- r_stepi; r_for3 <- r_gradi
      Uinit <- r[1]/2

      par_A <- as.character(r_B); par_B <- as.character(r_high)

    }

    if(change_par_x == "rK"){
      K_high <- K_A
      K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
      K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

      r_high <- r_A
      r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
      r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

      K <- K_stepi; K_for2 <- K_stepi; K_for3 <- K_gradi
      Binit <- K[1]/2

      r <- r_stepi; r_for2 <- r_stepi; r_for3 <- r_gradi
      Uinit <- r[1]/2

      par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

    }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
      all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy


  step_inc_s <- dfs_mm

  # grad decrease (true parameter has gradual decrease)
  change_type_x <- "grad"
  direction_x <- "decrease"

    # get the parameters to use
    if(change_par_x == "K"){

      K_low <- K_B
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd
      Binit <- K[1]/2

      r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
      Uinit <- r[1]/2

      par_A <- as.character(K_A); par_B <- as.character(K_low)
    }

    if(change_par_x == "r"){
      r_low <- r_B
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
      Binit <- K[1]/2

      r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- as.character(r_A); par_B <- as.character(r_low)

    }

    if(change_par_x == "rK"){
      K_low <- K_B
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      r_low <- r_B
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd
      Binit <- K[1]/2

      r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

    }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
      all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

  grad_dec_s <- dfs_mm

  # grad increase (true parameter has gradual increase)
  change_type_x <- "grad"
  direction_x <- "increase"

    # get the parameters to use
    if(change_par_x == "K"){

      K_high <- K_A
      K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
      K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

      K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi
      Binit <- K[1]/2

      r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
      Uinit <- r[1]/2

      par_A <- as.character(K_B); par_B <- as.character(K_high)
    }

    if(change_par_x == "r"){
      r_high <- r_A
      r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
      r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

      K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
      Binit <- K[1]/2

      r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi
      Uinit <- r[1]/2

      par_A <- as.character(r_B); par_B <- as.character(r_high)

    }

    if(change_par_x == "rK"){
      K_high <- K_A
      K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
      K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

      r_high <- r_A
      r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
      r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

      K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi
      Binit <- K[1]/2

      r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi
      Uinit <- r[1]/2

      par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

    }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
      all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

  grad_inc_s <- dfs_mm

  # periodic update decreases
  # (true parameter has gradual decrease, but gradual adaptive management scenario is periodic updates)

  for(uu in 1:length(update_ints)){
    change_type_x <- "grad" # true parameter is changing gradually
    direction_x <- "decrease"

    # new strategy names and change_refs: only consider the climate adaptive strategy when using periodic updates
    strat_names2 <- paste("update", update_ints[uu], sep = "_")
    change_refs2 <- 2

      # get the parameters to use
      if(change_par_x == "K"){

        K_low <- K_B
        K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
        K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)
        K_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepd, update_ints[uu])

        K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd_up
        Binit <- K[1]/2

        r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
        Uinit <- r[1]/2

        par_A <- as.character(K_A); par_B <- as.character(K_low)
      }

      if(change_par_x == "r"){
        r_low <- r_B
        r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
        r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)
        r_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepd, update_ints[uu])

        K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
        Binit <- K[1]/2

        r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd_up
        Uinit <- r[1]/2

        par_A <- as.character(r_A); par_B <- as.character(r_low)

      }

      if(change_par_x == "rK"){
        K_low <- K_B
        K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
        K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)
        K_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepd, update_ints[uu])

        r_low <- r_B
        r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
        r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)
        r_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepd, update_ints[uu])

        K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd_up
        Binit <- K[1]/2

        r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd_up
        Uinit <- r[1]/2

        par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

      }

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs2, delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names2, change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
      all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      dfs_mm <- all_jmm

    if(uu==1){
      dfs2 <- dfs_mm
    } else{
      dfs2 <- rbind(dfs_mm, dfs2)
    }

  }

  update_dec_s <- dfs2

  # periodic update increases
  # (true parameter has gradual increase, but gradual adaptive management scenario is periodic updates)

  for(uu in 1:length(update_ints)){
    change_type_x <- "grad"
    direction_x <- "increase"

    # new strategy names and change_refs: only consider the climate adaptive strategy when using periodic updates
    strat_names2 <- paste("update", update_ints[uu], sep = "_")
    change_refs2 <- 2

      # get the parameters to use
      if(change_par_x == "K"){

        K_high <- K_A
        K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
        K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)
        K_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepi, update_ints[uu])

        K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi_up
        Binit <- K[1]/2

        r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
        Uinit <- r[1]/2

        par_A <- as.character(K_B); par_B <- as.character(K_high)
      }

      if(change_par_x == "r"){
        r_high <- r_A
        r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
        r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)
        r_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepi, update_ints[uu])

        K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
        Binit <- K[1]/2

        r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi_up
        Uinit <- r[1]/2

        par_A <- as.character(r_B); par_B <- as.character(r_high)

      }

      if(change_par_x == "rK"){
        K_high <- K_A
        K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
        K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)
        K_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepi, update_ints[uu])

        r_high <- r_A
        r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
        r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)
        r_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepi, update_ints[uu])

        K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi_up
        Binit <- K[1]/2

        r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi_up
        Uinit <- r[1]/2

        par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

      }

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs2, delta_set, p, HCR_fun, HCR_fixed_pars,
                          use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names2, change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set,
                   error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # turn results into data frame
      all_jmm <- ts_results_fun(sim_jmm, pars)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))

      dfs_mm <- all_jmm

    if(uu==1){
      dfs2 <- dfs_mm
    } else{
      dfs2 <- rbind(dfs_mm, dfs2)
    }

  }

  update_inc_s <- dfs2

  # combine results
  ts_df <- rbind(step_dec_s, step_inc_s, grad_dec_s, grad_inc_s, update_dec_s, update_inc_s)

  return(ts_df)

}

```



```{r}
# make the dataframe and save it

update_ints <- c(4, 10) # set of periodic update intervals
B_cons_set <- c(1.2, 0.5) # biomass limits for conservation concern

for(i in 1:length(B_cons_set)){
B_cons <- B_cons_set[i]

change_par_x <- "K"
K_AB_ts_df <- tsruns_fun(change_par_x, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "r"
r_AB_ts_df <- tsruns_fun(change_par_x, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "rK"
rK_AB_ts_df <- tsruns_fun(change_par_x, K_A, K_B, r_A, r_B, update_ints)

ABts_df_i <- rbind(K_AB_ts_df, r_AB_ts_df, rK_AB_ts_df)

if(i==1){
  ABts_df <- ABts_df_i
} else{
  ABts_df <- rbind(ABts_df_i, ABts_df)
}

}

write_csv(ABts_df, here::here('simulation output/ABts_df.csv'))

```


## ABCDsens_update

(note this includes the old ABCDsens results, but also includes periodic update scenario)


```{r}



# function for running sensitivity analyses to difference in initial and final K and/or r
# function of which parameter(s) to change (r, K, rK) and sets of percent decreases and percent increases, also a function of the set of update intervals for the periodic update scenario
sensABCD_fun <- function(change_par_x, dec_set, inc_set, K_A, K_B, r_A, r_B, update_ints){

   # make the fixed parameter sets
   K_fixed <- rep(K_A, years) 
   r_fixed <- rep(r_A, years)

  # step decrease (true parameter has step decrease)
  change_type_x <- "step"
  direction_x <- "decrease"

  for(j in 1:length(dec_set)){

    # get the parameters to use
    if(change_par_x == "K"){

      K_low <- (-dec_set[j]*K_A + K_A)
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      K <- K_stepd; K_for2 <- K_stepd; K_for3 <- K_gradd
      #Binit <- 0.4*K[1]
      Binit <- K[1]/2

      r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
      Uinit <- r[1]/2

      par_A <- as.character(K_A); par_B <- as.character(K_low)
    }

    if(change_par_x == "r"){
      r_low <- (-dec_set[j]*r_A + r_A)
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
      Binit <- K[1]/2

      r <- r_stepd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- as.character(r_A); par_B <- as.character(r_low)

    }

    if(change_par_x == "rK"){
      K_low <- (-dec_set[j]*K_A + K_A)
      K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
      K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

      r_low <- (-dec_set[j]*r_A + r_A)
      r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
      r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

      K <- K_stepd; K_for2 <- K_stepd; K_for3 <- K_gradd
      Binit <- K[1]/2

      r <- r_stepd; r_for2 <- r_stepd; r_for3 <- r_gradd
      Uinit <- r[1]/2

      par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

    }


    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$per_change <- rep(-dec_set[j]*100, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  step_dec_s <- dfs

  # step increase (true parameter has step increase)
  change_type_x <- "step"
  direction_x <- "increase"

  for(j in 1:length(inc_set)){
  # get the parameters to use
  if(change_par_x == "K"){

    K_high <- (inc_set[j]*K_B + K_B)
    K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
    K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

    K <- K_stepi; K_for2 <- K_stepi; K_for3 <- K_gradi
    Binit <- K[1]/2

    r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
    Uinit <- r[1]/2

    par_A <- as.character(K_B); par_B <- as.character(K_high)
  }

  if(change_par_x == "r"){
    r_high <- (inc_set[j]*r_B + r_B)
    r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
    r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

    K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
    Binit <- K[1]/2

    r <- r_stepi; r_for2 <- r_stepi; r_for3 <- r_gradi
    Uinit <- r[1]/2

    par_A <- as.character(r_B); par_B <- as.character(r_high)

  }

  if(change_par_x == "rK"){
    K_high <- (inc_set[j]*K_B + K_B)
    K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
    K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

    r_high <- (inc_set[j]*r_B + r_B)
    r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
    r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

    K <- K_stepi; K_for2 <- K_stepi; K_for3 <- K_gradi
    Binit <- K[1]/2

    r <- r_stepi; r_for2 <- r_stepi; r_for3 <- r_gradi
    Uinit <- r[1]/2

    par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

  }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2, K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, 
                   discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA,  B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$per_change <- rep(inc_set[j]*100, length(all_jmm[,1]))


      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }


  }

  step_inc_s <- dfs

  # grad decrease (true parameter has gradual decrease)
  change_type_x <- "grad"
  direction_x <- "decrease"

  for(j in 1:length(dec_set)){
  # get the parameters to use
  if(change_par_x == "K"){

    K_low <- (-dec_set[j]*K_A + K_A)
    K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
    K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

    K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd
    Binit <- K[1]/2

    r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
    Uinit <- r[1]/2

    par_A <- as.character(K_A); par_B <- as.character(K_low)
  }

  if(change_par_x == "r"){
    r_low <- (-dec_set[j]*r_A + r_A)
    r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
    r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

    K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
    Binit <- K[1]/2

    r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd
    Uinit <- r[1]/2

    par_A <- as.character(r_A); par_B <- as.character(r_low)

  }

  if(change_par_x == "rK"){
    K_low <- (-dec_set[j]*K_A + K_A)
    K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
    K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)

    r_low <- (-dec_set[j]*r_A + r_A)
    r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
    r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)

    K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd
    Binit <- K[1]/2

    r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd
    Uinit <- r[1]/2

    par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

  }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2, K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$per_change <- rep(-dec_set[j]*100, length(all_jmm[,1]))


      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_dec_s <- dfs

  # grad increase (true parameter has gradual increase)
  change_type_x <- "grad"
  direction_x <- "increase"

  for(j in 1:length(inc_set)){
  # get the parameters to use
  if(change_par_x == "K"){

    K_high <- (inc_set[j]*K_B + K_B)
    K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
    K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

    K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi
    Binit <- K[1]/2

    r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
    Uinit <- r[1]/2

    par_A <- as.character(K_B); par_B <- as.character(K_high)
  }

  if(change_par_x == "r"){
    r_high <- (inc_set[j]*r_B + r_B)
    r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
    r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

    K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
    Binit <- K[1]/2

    r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi
    Uinit <- r[1]/2

    par_A <- as.character(r_B); par_B <- as.character(r_high)

  }

  if(change_par_x == "rK"){
    K_high <- (inc_set[j]*K_B + K_B)
    K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
    K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)

    r_high <- (inc_set[j]*r_B + r_B)
    r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
    r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)

    K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi
    Binit <- K[1]/2

    r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi
    Uinit <- r[1]/2

    par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

  }

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,  use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
      all_jmm$per_change <- rep(inc_set[j]*100, length(all_jmm[,1]))

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_inc_s <- dfs

  # periodic update decreases
  # (true parameter has gradual decrease, but gradual adaptive management scenario is periodic updates)

  for(uu in 1:length(update_ints)){
    change_type_x <- "grad" # true parameter is changing gradually
    direction_x <- "decrease"

    # new strategy names and change_refs: only consider the climate adaptive strategy when using periodic updates
    strat_names2 <- paste("update", update_ints[uu], sep = "_")
    change_refs2 <- 2

    for(j in 1:length(dec_set)){
      # get the parameters to use
      if(change_par_x == "K"){

        K_low <- (-dec_set[j]*K_A + K_A)
        K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
        K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)
        K_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepd, update_ints[uu])

        K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd_up
        Binit <- K[1]/2

        r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
        Uinit <- r[1]/2

        par_A <- as.character(K_A); par_B <- as.character(K_low)
      }

      if(change_par_x == "r"){
        r_low <- (-dec_set[j]*r_A + r_A)
        r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
        r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)
        r_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepd, update_ints[uu])

        K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
        Binit <- K[1]/2

        r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd_up
        Uinit <- r[1]/2

        par_A <- as.character(r_A); par_B <- as.character(r_low)

      }

      if(change_par_x == "rK"){
        K_low <- (-dec_set[j]*K_A + K_A)
        K_stepd <- c(rep(K_A,length(1:chng_pt2)),rep(K_low,length((chng_pt2+1):years)))
        K_gradd <- par_for_fun(chng_pt, chng_pt2, years, K_stepd)
        K_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepd, update_ints[uu])

        r_low <- (-dec_set[j]*r_A + r_A)
        r_stepd <- c(rep(r_A,length(1:chng_pt2)),rep(r_low,length((chng_pt2+1):years)))
        r_gradd <- par_for_fun(chng_pt, chng_pt2, years, r_stepd)
        r_gradd_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepd, update_ints[uu])

        K <- K_gradd; K_for2 <- K_stepd; K_for3 <- K_gradd_up
        Binit <- K[1]/2

        r <- r_gradd; r_for2 <- r_stepd; r_for3 <- r_gradd_up
        Uinit <- r[1]/2

        par_A <- paste(as.character(r_A), as.character(K_A), sep = "_"); par_B <- paste(as.character(r_low), as.character(K_low), sep = "_")

      }


        sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                            K_for3, change_ref = change_refs2, delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

        pars <- list(hcr_type = "slope", strategy = strat_names2, change_par = change_par_x,
                     change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                     years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

        # pre, post, and total periods
        tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
        pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
        post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

        all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

        all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
        all_jmm$per_change <- rep(-dec_set[j]*100, length(all_jmm[,1]))

        dfs_mm <- all_jmm

      if(j==1){
        dfs <- dfs_mm
      } else{
        dfs <- rbind(dfs_mm, dfs)
      }

    }

    if(uu==1){
      dfs2 <- dfs
    } else{
      dfs2 <- rbind(dfs, dfs2)
    }

  }

  update_dec_s <- dfs2

  # periodic update increases
  # (true parameter has gradual increase, but gradual adaptive management scenario is periodic updates)

  for(uu in 1:length(update_ints)){
    change_type_x <- "grad"
    direction_x <- "increase"

    # new strategy names and change_refs: only consider the climate adaptive strategy when using periodic updates
    strat_names2 <- paste("update", update_ints[uu], sep = "_")
    change_refs2 <- 2

    for(j in 1:length(inc_set)){
      # get the parameters to use
      if(change_par_x == "K"){

        K_high <- (inc_set[j]*K_B + K_B)
        K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
        K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)
        K_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepi, update_ints[uu])

        K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi_up
        Binit <- K[1]/2

        r <- r_fixed; r_for2 <- r_fixed; r_for3 <- r_fixed
        Uinit <- r[1]/2

        par_A <- as.character(K_B); par_B <- as.character(K_high)
      }

      if(change_par_x == "r"){
        r_high <- (inc_set[j]*r_B + r_B)
        r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
        r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)
        r_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepi, update_ints[uu])

        K <- K_fixed; K_for2 <- K_fixed; K_for3 <- K_fixed
        Binit <- K[1]/2

        r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi_up
        Uinit <- r[1]/2

        par_A <- as.character(r_B); par_B <- as.character(r_high)

      }

      if(change_par_x == "rK"){
        K_high <- (inc_set[j]*K_B + K_B)
        K_stepi <- rev(c(rep(K_high,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years))))
        K_gradi <- par_for_fun(chng_pt, chng_pt2, years, K_stepi)
        K_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, K_stepi, update_ints[uu])

        r_high <- (inc_set[j]*r_B + r_B)
        r_stepi <- rev(c(rep(r_high,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years))))
        r_gradi <- par_for_fun(chng_pt, chng_pt2, years, r_stepi)
        r_gradi_up <- update_par_fun(chng_pt, chng_pt2, years, r_stepi, update_ints[uu])

        K <- K_gradi; K_for2 <- K_stepi; K_for3 <- K_gradi_up
        Binit <- K[1]/2

        r <- r_gradi; r_for2 <- r_stepi; r_for3 <- r_gradi_up
        Uinit <- r[1]/2

        par_A <- paste(as.character(r_B), as.character(K_B), sep = "_"); par_B <- paste(as.character(r_high), as.character(K_high), sep = "_")

      }


        sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                            K_for3, change_ref = change_refs2, delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

        pars <- list(hcr_type = "slope", strategy = strat_names2, change_par = change_par_x,
                     change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                     years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

        # pre, post, and total periods
        tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
        pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
        post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

        all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

        all_jmm$par_A <- rep(par_A, length(all_jmm[,1]))
        # all_jmm$par_B <- rep(par_B, length(all_jmm[,1]))
        all_jmm$per_change <- rep(inc_set[j]*100, length(all_jmm[,1]))

        dfs_mm <- all_jmm

      if(j==1){
        dfs <- dfs_mm
      } else{
        dfs <- rbind(dfs_mm, dfs)
      }

    }

    if(uu==1){
      dfs2 <- dfs
    } else{
      dfs2 <- rbind(dfs, dfs2)
    }

  }

  update_inc_s <- dfs2

  # combine results
  sens_df <- rbind(step_dec_s, step_inc_s, grad_dec_s, grad_inc_s, update_dec_s, update_inc_s)

  return(sens_df)

}



```



```{r}
# run simulations and save results

dec_set <- c(0.15, 0.3, 0.45, 0.6, 0.75, 0.9)
inc_set <- c(0.5, 1, 1.5, 2, 2.5, 3, 3.5)
update_ints <- c(4, 10)
B_cons_set <- c(1.2, 0.5)

for(i in 1:length(B_cons_set)){
B_cons <- B_cons_set[i]

change_par_x <- "K"
K_ABCD_sens_df <- sensABCD_fun(change_par_x, dec_set, inc_set, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "r"
r_ABCD_sens_df <- sensABCD_fun(change_par_x, dec_set, inc_set, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "rK"
rK_ABCD_sens_df <- sensABCD_fun(change_par_x, dec_set, inc_set, K_A, K_B, r_A, r_B, update_ints)

ABCDsens_df_i <- rbind(K_ABCD_sens_df, r_ABCD_sens_df, rK_ABCD_sens_df)

if(i==1){
  ABCDsens_update_df <- ABCDsens_df_i
} else{
  ABCDsens_update_df <- rbind(ABCDsens_df_i, ABCDsens_update_df)
}

}


# save results
write_csv(ABCDsens_update_df, here::here('simulation output/ABCDsens_update_df.csv'))


```


## repeat w/ stochasticity

```{r}
# run the simulations and save results

dec_set.2 <- c(0.75) # just use value used in Fig 2
inc_set.2 <- c(3) # just use value useed in Fig 2
update_ints <- c(4, 10)
B_cons_set.2 <- c(1.2) # just run value used in Fig 2

# get error sets
seed <- 500
rho <- 0.5 # strength of autocorrelation
cv <- 0.8 # how variable dynamics are (sigma2	=	log(cv^2 + 1))
nreps <- 100 # do 100 replicates

all_errors <- error_fun(cv, rho, years, nreps, seed) # error_fun is the function for generating the errors; this is in functions/model_funs


for(k in 1:nreps){ # for each error replicate
  
  # get the errors to use... note I'm naming them "no_errors" here because that's what the sensABCD_fun expects and this seemed quicker than going back and remaking another version of the sensABCD_fun
  no_errors <- all_errors[[k]]

for(i in 1:length(B_cons_set.2)){
B_cons <- B_cons_set.2[i]

change_par_x <- "K"
K_ABCD_stoch_df <- sensABCD_fun(change_par_x, dec_set.2, inc_set.2, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "r"
r_ABCD_stoch_df <- sensABCD_fun(change_par_x, dec_set.2, inc_set.2, K_A, K_B, r_A, r_B, update_ints)

change_par_x <- "rK"
rK_ABCD_stoch_df <- sensABCD_fun(change_par_x, dec_set.2, inc_set.2, K_A, K_B, r_A, r_B, update_ints)

ABCDstoch_df_i <- rbind(K_ABCD_stoch_df, r_ABCD_stoch_df, rK_ABCD_stoch_df)

if(i==1){
  ABCDstoch_update_df <- ABCDstoch_df_i
} else{
  ABCDstoch_update_df <- rbind(ABCDstoch_df_i, ABCDstoch_update_df)
}

}
  
  # add the error replicate as a column to the df
  ABCDstoch_update_df$error_rep <- rep(k, length(ABCDstoch_update_df$hcr_type))
  
  # add the error parameters (the default in the sensABCD_fun is to call these NA)
  ABCDstoch_update_df$error_rho <- rep(rho, length(ABCDstoch_update_df$hcr_type))
  ABCDstoch_update_df$error_cv <- rep(cv, length(ABCDstoch_update_df$hcr_type))
  
  
  if(k==1){
  ABCDstoch_update_df_full <- ABCDstoch_update_df
} else{
  ABCDstoch_update_df_full <- rbind(ABCDstoch_update_df, ABCDstoch_update_df_full)
}

}
  
# reset no_errors so subsequent simulations don't have stochasticity
no_errors <- rep(1, years)


# save results (just the scenarios that are used in Figure 2)
ABCDstoch_update_df_short <- ABCDstoch_update_df_full %>% filter(period == 'pre') %>% filter(strategy != 'ACA') %>% filter(change_type == 'grad')# grad = true par has gradual change


View(ABCDstoch_update_df_short)

write_csv(ABCDstoch_update_df_short, here::here('simulation output/ABCDstoch_update_df_short.csv'))

```


```{r}
# check results

# value_test <- ABCDstoch_update_df_short$value[which(ABCDstoch_update_df_short$strategy=="GCA" & ABCDstoch_update_df_short$change_par=="K" & ABCDstoch_update_df_short$direction=="decrease" & ABCDstoch_update_df_short$metric=="Bmn")]
# 
# no_stoch_val <- ABCDsens_update_df$value[which(ABCDsens_update_df$strategy=="GCA" & ABCDsens_update_df$change_par=="K" & ABCDsens_update_df$direction=="decrease" & ABCDsens_update_df$metric=="Bmn" & ABCDsens_update_df$period=="pre" & ABCDsens_update_df$change_type=="grad" & ABCDsens_update_df$B_cons==1.2 & ABCDsens_update_df$per_change==-75)]
# 
# 
# hist(value_test)
# abline(v = no_stoch_val, col = "blue", lwd = 2)



```


## B0sens

Sensitivity to initial biomass


```{r}
# function for running simulations with different initial biomass values

# function of which parameter(s) to change (r, K, rK) and set of initial population sizes (as fractions of initial carrying capacity)
sensB0_fun <- function(change_par_x, Bfrac_set){

  # set up the parameter vectors (this function assumes all of these were defined outside the function)
  # have four change scenarios: step decrease, step increase, grad decrease, and grad increase
  if(change_par_x == "K"){

    # sets of parameter values: 1 = step decrease, 2 = step increase, 3 = grad decrease, 4 = grad increase
    K_set <- list(K_stepd, K_stepi, K_gradd, K_gradi)
    K_for2_set <- list(K_stepd, K_stepi, K_stepd, K_stepi) # abrupt climate adaptive
    K_for3_set <- list(K_gradd, K_gradi, K_gradd, K_gradi) # gradual climate adaptive

    # r values
    r_set <- list(r_fixedd, r_fixedd, r_fixedd, r_fixedd) # r stays at high value for all change scenarios
    # set values for r here since they won't change for the different K scenarios
    r_for2_set <- list(r_fixedd, r_fixedd, r_fixedd, r_fixedd) # no change for abrupt climate adaptive
    r_for3_set <- list(r_fixedd, r_fixedd, r_fixedd, r_fixedd) # no change for gradual climate adaptive

  }

  if(change_par_x == "r"){

    # K values
    K_set <- list(K_fixedd, K_fixedd, K_fixedd, K_fixedd) # K stays at high value
    # set values for K here since they won't change for the different r scenarios
    K_for2_set <- list(K_fixedd, K_fixedd, K_fixedd, K_fixedd) # no change for abrupt climate adaptive
    K_for3_set <- list(K_fixedd, K_fixedd, K_fixedd, K_fixedd) # no change for gradual climate adaptive

    # r values
    r_set <- list(r_stepd, r_stepi, r_gradd, r_gradi)
    r_for2_set <- list(r_stepd, r_stepi, r_stepd, r_stepi) # abrupt climate adaptive
    r_for3_set <- list(r_gradd, r_gradi, r_gradd, r_gradi) # gradual climate adaptive
  }

  if(change_par_x == "rK"){

    # K values
    K_set <- list(K_stepd, K_stepi, K_gradd, K_gradi)
    K_for2_set <- list(K_stepd, K_stepi, K_stepd, K_stepi) # abrupt climate adaptive
    K_for3_set <- list(K_gradd, K_gradi, K_gradd, K_gradi) # gradual climate adaptive

    # r values
    r_set <- list(r_stepd, r_stepi, r_gradd, r_gradi)
    r_for2_set <- list(r_stepd, r_stepi, r_stepd, r_stepi) # abrupt climate adaptive
    r_for3_set <- list(r_gradd, r_gradi, r_gradd, r_gradi) # gradual climate adaptive

  }


  # first scenario: step decrease
  change_type_x <- "step"
  direction_x <- "decrease"

  K <- K_set[[1]]
  K_for2 <- K_for2_set[[1]]
  K_for3 <- K_for3_set[[1]]
  r <- r_set[[1]]
  r_for2 <- r_for2_set[[1]]
  r_for3 <- r_for3_set[[1]]

  Uinit <- r[1]/2

  Binit_set<-K[1]*Bfrac_set # initial biomass -> represents different levels of initial exploitation

  for(j in 1:length(Binit_set)){

    Binit_j <- Binit_set[j] # Binit is the first column of parmat

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit = Binit_j, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit_j, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  step_dec_s <- dfs

  # second scenario: step increase
  change_type_x <- "step"
  direction_x <- "increase"

  K <- K_set[[2]]
  K_for2 <- K_for2_set[[2]]
  K_for3 <- K_for3_set[[2]]
  r <- r_set[[2]]
  r_for2 <- r_for2_set[[2]]
  r_for3 <- r_for3_set[[2]]

  Uinit <- r[1]/2

  Binit_set<-K[1]*Bfrac_set # initial biomass -> represents different levels of initial exploitation

  for(j in 1:length(Binit_set)){

    Binit_j <- Binit_set[j] # Binit is the first column of parmat

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit = Binit_j, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit_j, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  step_inc_s <- dfs

  # third scenario: grad decrease
  change_type_x <- "grad"
  direction_x <- "decrease"

  K <- K_set[[3]]
  K_for2 <- K_for2_set[[3]]
  K_for3 <- K_for3_set[[3]]
  r <- r_set[[3]]
  r_for2 <- r_for2_set[[3]]
  r_for3 <- r_for3_set[[3]]

  Uinit <- r[1]/2

  Binit_set<-K[1]*Bfrac_set # initial biomass -> represents different levels of initial exploitation

  for(j in 1:length(Binit_set)){

    Binit_j <- Binit_set[j] # Binit is the first column of parmat

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit = Binit_j, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit_j, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_dec_s <- dfs

  # fourth scenario: grad increase
  change_type_x <- "grad"
  direction_x <- "increase"

  K <- K_set[[4]]
  K_for2 <- K_for2_set[[4]]
  K_for3 <- K_for3_set[[4]]
  r <- r_set[[4]]
  r_for2 <- r_for2_set[[4]]
  r_for3 <- r_for3_set[[4]]

  Uinit <- r[1]/2

  Binit_set<-K[1]*Bfrac_set# initial biomass -> represents different levels of initial exploitation

  for(j in 1:length(Binit_set)){

    Binit_j <- Binit_set[j] # Binit is the first column of parmat

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit = Binit_j, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit_j, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_inc_s <- dfs

  # combine results
  sens_df <- rbind(step_dec_s, step_inc_s, grad_dec_s, grad_inc_s)

  return(sens_df)

}


```


```{r}
# run simulations and save results

Bfrac_set <- c(0.1, 0.2, 0.3, 0.4, 0.5) # initial fractions of carrying capacity at which to start the population 

K_sens_df <- sensB0_fun("K", Bfrac_set)

r_sens_df <- sensB0_fun("r", Bfrac_set)

rK_sens_df <- sensB0_fun("rK", Bfrac_set)


# save results
B0sens_df <- rbind(K_sens_df, r_sens_df, rK_sens_df)

write_csv(B0sens_df, here::here('simulation output/B0sens_df.csv'))

```



## Tchng

Sensitivity to tchange (timepoint when r and/or K reaches its final value)

```{r}

# function for running sensitivity analyses to t_change
sensTchange_fun <- function(change_par_x, Tchange_set){

  # set up the parameter vectors (this function assumes all of these were defined outside the function)
  # have four change scenarios: step decrease, step increase, grad decrease, and grad increase
  if(change_par_x == "K"){

    # make a nested list where outermost is change scenario (step/grad, increase/decrease) and innermost
    # are the values for each t_change value
    K_stepds <- list()
    K_stepis <- list()
    K_gradds <- list()
    K_gradis <- list()
    r_fixedds <- list()

    for(j in 1:length(Tchange_set)){
      chng_pt2 <- Tchange_set[j]

      K_stepds[[j]] <- c(rep(K_A,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years)))
      K_gradds[[j]] <- par_for_fun(chng_pt, chng_pt2, years, K_stepds[[j]])
      K_stepis[[j]] <- rev(K_stepds[[j]])
      K_gradis[[j]] <- par_for_fun(chng_pt, chng_pt2, years, K_stepis[[j]])

      r_fixedds[[j]] <- r_fixedd # r stays at high value for all change scenarios

    }

    # sets of parameter values: 1 = step decrease, 2 = step increase, 3 = grad decrease, 4 = grad increase
    K_set <- list(K_stepds, K_stepis, K_gradds, K_gradis)
    K_for2_set <- list(K_stepds, K_stepis, K_stepds, K_stepis) # abrupt climate adaptive
    K_for3_set <- list(K_gradds, K_gradis, K_gradds, K_gradis) # gradual climate adaptive

    r_set <- list(r_fixedds, r_fixedds, r_fixedds, r_fixedds)
    r_for2_set <- list(r_fixedds, r_fixedds, r_fixedds, r_fixedds)
    r_for3_set <- list(r_fixedds, r_fixedds, r_fixedds, r_fixedds)

  }

  if(change_par_x == "r"){

    r_stepds <- list()
    r_stepis <- list()
    r_gradds <- list()
    r_gradis <- list()
    K_fixedds <- list()

    for(j in 1:length(Tchange_set)){
      chng_pt2 <- Tchange_set[j]

      r_stepds[[j]] <- c(rep(r_A,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years)))
      r_gradds[[j]] <- par_for_fun(chng_pt, chng_pt2, years, r_stepds[[j]])
      r_stepis[[j]] <- rev(r_stepds[[j]])
      r_gradis[[j]] <- par_for_fun(chng_pt, chng_pt2, years, r_stepis[[j]])

      K_fixedds[[j]] <- K_fixedd # r stays at high value for all change scenarios

    }


    # sets of parameter values: 1 = step decrease, 2 = step increase, 3 = grad decrease, 4 = grad increase
    r_set <- list(r_stepds, r_stepis, r_gradds, r_gradis)
    r_for2_set <- list(r_stepds, r_stepis, r_stepds, r_stepis) # abrupt climate adaptive
    r_for3_set <- list(r_gradds, r_gradis, r_gradds, r_gradis) # gradual climate adaptive

    K_set <- list(K_fixedds, K_fixedds, K_fixedds, K_fixedds)
    K_for2_set <- list(K_fixedds, K_fixedds, K_fixedds, K_fixedds)
    K_for3_set <- list(K_fixedds, K_fixedds, K_fixedds, K_fixedds)

  }

  if(change_par_x == "rK"){

    K_stepds <- list()
    K_stepis <- list()
    K_gradds <- list()
    K_gradis <- list()

    r_stepds <- list()
    r_stepis <- list()
    r_gradds <- list()
    r_gradis <- list()

    for(j in 1:length(Tchange_set)){
      chng_pt2 <- Tchange_set[j]

      K_stepds[[j]] <- c(rep(K_A,length(1:chng_pt2)),rep(K_B,length((chng_pt2+1):years)))
      K_gradds[[j]] <- par_for_fun(chng_pt, chng_pt2, years, K_stepds[[j]])
      K_stepis[[j]] <- rev(K_stepds[[j]])
      K_gradis[[j]] <- par_for_fun(chng_pt, chng_pt2, years, K_stepis[[j]])

      r_stepds[[j]] <- c(rep(r_A,length(1:chng_pt2)),rep(r_B,length((chng_pt2+1):years)))
      r_gradds[[j]] <- par_for_fun(chng_pt, chng_pt2, years, r_stepds[[j]])
      r_stepis[[j]] <- rev(r_stepds[[j]])
      r_gradis[[j]] <- par_for_fun(chng_pt, chng_pt2, years, r_stepis[[j]])

    }

    # K values
    K_set <- list(K_stepds, K_stepis, K_gradds, K_gradis)
    K_for2_set <- list(K_stepds, K_stepis, K_stepds, K_stepis) # abrupt climate adaptive
    K_for3_set <- list(K_gradds, K_gradis, K_gradds, K_gradis) # gradual climate adaptive

    # r values
    r_set <- list(r_stepds, r_stepis, r_gradds, r_gradis)
    r_for2_set <- list(r_stepds, r_stepis, r_stepds, r_stepis) # abrupt climate adaptive
    r_for3_set <- list(r_gradds, r_gradis, r_gradds, r_gradis) # gradual climate adaptive

  }


  # first scenario: step decrease
  change_type_x <- "step"
  direction_x <- "decrease"

  Ks <- K_set[[1]]
  K_for2s <- K_for2_set[[1]]
  K_for3s <- K_for3_set[[1]]
  rs <- r_set[[1]]
  r_for2s <- r_for2_set[[1]]
  r_for3s <- r_for3_set[[1]]

  for(j in 1:length(Tchange_set)){

    chng_pt2 <- Tchange_set[j]
    chng_time2 <- chng_pt2

    K <- Ks[[j]]
    K_for2 <- K_for2s[[j]]
    K_for3 <- K_for3s[[j]]
    r <- rs[[j]]
    r_for2 <- r_for2s[[j]]
    r_for3 <- r_for3s[[j]]

    Uinit <- r[1]/2
    Binit<-K[1]/2 # initial biomass -> represents different levels of initial exploitation

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }


  step_dec_s <- dfs


  # second scenario: step increase
  change_type_x <- "step"
  direction_x <- "increase"

  Ks <- K_set[[2]]
  K_for2s <- K_for2_set[[2]]
  K_for3s <- K_for3_set[[2]]
  rs <- r_set[[2]]
  r_for2s <- r_for2_set[[2]]
  r_for3s <- r_for3_set[[2]]

  for(j in 1:length(Tchange_set)){

    chng_pt2 <- Tchange_set[j]
    chng_time2 <- chng_pt2

    K <- Ks[[j]]
    K_for2 <- K_for2s[[j]]
    K_for3 <- K_for3s[[j]]
    r <- rs[[j]]
    r_for2 <- r_for2s[[j]]
    r_for3 <- r_for3s[[j]]

    Uinit <- r[1]/2
    Binit<-K[1]/2 # initial biomass -> represents different levels of initial exploitation


    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars,use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  step_inc_s <- dfs

  # third scenario: grad decrease
  change_type_x <- "grad"
  direction_x <- "decrease"

  Ks <- K_set[[3]]
  K_for2s <- K_for2_set[[3]]
  K_for3s <- K_for3_set[[3]]
  rs <- r_set[[3]]
  r_for2s <- r_for2_set[[3]]
  r_for3s <- r_for3_set[[3]]

  for(j in 1:length(Tchange_set)){

    chng_pt2 <- Tchange_set[j]
    chng_time2 <- chng_pt2

    K <- Ks[[j]]
    K_for2 <- K_for2s[[j]]
    K_for3 <- K_for3s[[j]]
    r <- rs[[j]]
    r_for2 <- r_for2s[[j]]
    r_for3 <- r_for3s[[j]]

    Uinit <- r[1]/2
    Binit<-K[1]/2 # initial biomass -> represents different levels of initial exploitation

    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_dec_s <- dfs

  # fourth scenario: grad increase
  change_type_x <- "grad"
  direction_x <- "increase"

  Ks <- K_set[[4]]
  K_for2s <- K_for2_set[[4]]
  K_for3s <- K_for3_set[[4]]
  rs <- r_set[[4]]
  r_for2s <- r_for2_set[[4]]
  r_for3s <- r_for3_set[[4]]

  for(j in 1:length(Tchange_set)){

    chng_pt2 <- Tchange_set[j]
    chng_time2 <- chng_pt2

    K <- Ks[[j]]
    K_for2 <- K_for2s[[j]]
    K_for3 <- K_for3s[[j]]
    r <- rs[[j]]
    r_for2 <- r_for2s[[j]]
    r_for3 <- r_for3s[[j]]

    Uinit <- r[1]/2
    Binit<-K[1]/2 # initial biomass -> represents different levels of initial exploitation


    # run the simulations for each management strategy
    for(mm in 1:length(change_refs)){

      sim_jmm <- proj_pop(years, no_errors, r, r_for2, r_for3, Binit, Uinit, K, K_for2,
                          K_for3, change_ref = change_refs[mm], delta_set, p, HCR_fun, HCR_fixed_pars, use_HCR=TRUE)

      pars <- list(hcr_type = "slope", strategy = strat_names[mm], change_par = change_par_x,
                   change_type = change_type_x, direction = direction_x, chng_pt2 = chng_pt2,
                   years = years, Binit = Binit, chng_time2 = chng_time2, discount_rates = delta_set, error_rho = NA, error_cv = NA, error_rep = NA, B_cons = B_cons)

      # pre, post, and total periods
      tot_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = years)
      pre_jmm <- results_fun(sim_jmm, pars, t_start = 1, t_end = chng_pt2 - 1)
      post_jmm <- results_fun(sim_jmm, pars, t_start = chng_pt2, t_end = years)

      all_jmm <- rbind(tot_jmm, pre_jmm, post_jmm)

      # join all the results for the mm^th strategy:
      if(mm == 1){
        dfs_mm <- all_jmm
      } else{
        dfs_mm <- rbind(all_jmm, dfs_mm)
      }

    } # end of iterations for each management strategy

    if(j==1){
      dfs <- dfs_mm
    } else{
      dfs <- rbind(dfs_mm, dfs)
    }

  }

  grad_inc_s <- dfs

  # combine results
  sens_df <- rbind(step_dec_s, step_inc_s, grad_dec_s, grad_inc_s)

  return(sens_df)

}


```



```{r}

# run simulations and save results

Tchng_set <- c(10, 30, 50, 70, 90) # time points when r and/or K reaches final value

K_sens_df2 <- sensTchange_fun("K", Tchng_set)

r_sens_df2 <- sensTchange_fun("r", Tchng_set)

rK_sens_df2 <- sensTchange_fun("rK", Tchng_set)

Tchngsens_df <- rbind(K_sens_df2, r_sens_df2, rK_sens_df2)

write_csv(Tchngsens_df, here::here('simulation output/Tchng_df.csv'))

```



## barplot SM fig

```{r}

# make a function that takes the interval as an input and returns the average biomass and cumulative harvest during that period, then make dataframes with the percent differences in mean biomass and cumulative harvest between the fixed and gradual climate adaptive strategies over specified time intervals

intsumm_fun <- function(t1, t2, B_ts, H_ts){
  Bmn <- mean(B_ts[t1:t2]) # mean biomass in time interval
  Hcm <- sum(H_ts[t1:t2]) # cumulative harvest in time interval
  
  return(c(Bmn, Hcm))
}

# make a data frame with the percent differences between the fixed and gradual adaptive strategies over specified time intervals (years 1-16, 17-32, 33-48, 1-50)
t1_set <- c(1, 17, 33, 1)
t2_set <- c(16, 32, 48, 50)

# gradual decrease in K
# View(ABts_df)

sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "K", change_type == "grad", direction == "decrease", B_cons == 0.5) # K_grad_dec_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "K", change_type == "grad", direction == "decrease", B_cons == 0.5)# K_grad_dec_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

K_grad_dec_comp <- df
K_grad_dec_comp$scenario <- rep("K_grad_dec", length(df$t_int))


# gradual increase in K
sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "K", change_type == "grad", direction == "increase", B_cons == 0.5) #K_grad_inc_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "K", change_type == "grad", direction == "increase", B_cons == 0.5)#K_grad_inc_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

K_grad_inc_comp <- df
K_grad_inc_comp$scenario <- rep("K_grad_inc", length(df$t_int))

# gradual decrease in r
sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "r", change_type == "grad", direction == "decrease", B_cons == 0.5) #r_grad_dec_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "r", change_type == "grad", direction == "decrease", B_cons == 0.5)#r_grad_dec_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

r_grad_dec_comp <- df
r_grad_dec_comp$scenario <- rep("r_grad_dec", length(df$t_int))

# gradual increase in r
sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "r", change_type == "grad", direction == "increase", B_cons == 0.5) #r_grad_inc_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "r", change_type == "grad", direction == "increase", B_cons == 0.5)#r_grad_inc_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

r_grad_inc_comp <- df
r_grad_inc_comp$scenario <- rep("r_grad_inc", length(df$t_int))

# gradual decrease in r + K
sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "rK", change_type == "grad", direction == "decrease", B_cons == 0.5) #rK_grad_dec_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "rK", change_type == "grad", direction == "decrease", B_cons == 0.5)#rK_grad_dec_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

rK_grad_dec_comp <- df
rK_grad_dec_comp$scenario <- rep("rK_grad_dec", length(df$t_int))

# gradual increase in r + K
sq_sim <- ABts_df %>% filter(strategy == "SQ", change_par == "rK", change_type == "grad", direction == "increase", B_cons == 0.5) #rK_grad_inc_sq 
gca_sim <- ABts_df %>% filter(strategy == "GCA", change_par == "rK", change_type == "grad", direction == "increase", B_cons == 0.5)#rK_grad_inc_gca 

for(i in 1:length(t1_set)){
  
  sq_summ <- intsumm_fun(t1_set[i], t2_set[i], sq_sim$Biomass, sq_sim$Harvest)
  gca_summ <- intsumm_fun(t1_set[i], t2_set[i], gca_sim$Biomass, gca_sim$Harvest)
  
  B_diff <- (gca_summ[1]-sq_summ[1])/sq_summ[1]*100 # %diff in mean biomass
  H_diff <- (gca_summ[2]-sq_summ[2])/sq_summ[2]*100 # %diff in cumulative harvest
  
  # make dataframe
  df_i <- data.frame(
    t_int = rep(paste(as.character(t1_set[i]), as.character(t2_set[i]), sep = "-"),2),
    perc_diff = c(B_diff, H_diff),
    metric = c("Bmn", "Hcm")
  )
  
  if(i == 1){
    df <- df_i
  } else{
    df <- rbind(df, df_i)
  }

}

rK_grad_inc_comp <- df
rK_grad_inc_comp$scenario <- rep("rK_grad_inc", length(df$t_int))



# combine altogether and save

percdiff_ts_df <- rbind(K_grad_dec_comp, K_grad_inc_comp, r_grad_dec_comp, r_grad_inc_comp, rK_grad_dec_comp, rK_grad_inc_comp)

write_csv(percdiff_ts_df, here::here('simulation output/percdiff_ts_df.csv'))

```



















